#爬虫教程#
####1.获取网页内容
根据URL来获取它的网页信息，虽然我们在浏览器中看到的是一幅幅优美的画面，但是其实是由浏览器解释才呈现出来的，实质它是一段HTML代码，加 JS、CSS，如果把网页比作一个人，那么HTML便是他的骨架，JS便是他的肌肉，CSS便是它的衣服。所以最重要的部分是存在于HTML中。
```
import urllib2
request = urllib2.Request("http://www.baidu.com")
response = urllib2.urlopen(request)
print response.read()
```
首先构造一个request类实例，构造时传入参数url、data、timeout等。
#####通过urllib2库的urlopen方法获得网页内容。urlopen一般接受三个参数，它的参数如下：
第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。
第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT
###Timeout 参数设置###
Timeout用于设置等待多久超时，解决一些网站响应过慢的问题。
``` 
import urllib2
response = urllib2.urlopen('http://www.baidu.com', timeout=10)
or    
import urllib2
response = urllib2.urlopen('http://www.baidu.com', data, 10)
```

####2.POST和GET数据传送
对于动态网页，需要动态地传递参数给网页，POST和GET就是数据传送的两种方式。

####POST方式####
```
import urllib
import urllib2
 
values = {"username":"xxxxx","password":"XXXX"}
data = urllib.urlencode(values) 
url = "https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"
request = urllib2.Request(url,data)
response = urllib2.urlopen(request)
print response.read()
```
我们引入了urllib库，现在我们模拟登陆CSDN，当然上述代码可能登陆不进去，因为CSDN还有个流水号的字段，没有设置全，比较复杂在这里就不写上去了，在此只是说明登录的原理。一般的登录网站一般是这种写法。

我们需要定义一个字典，名字为values，参数我设置了username和password，下面利用urllib的urlencode方法将字典编码，命名为data，构建request时传入两个参数，url和data，运行程序，返回的便是POST后呈现的页面内容。
这就是POST方式的实现。

##GET方式##
至于GET方式我们可以直接把参数写到网址上面，直接构建一个带参数的URL出来即可。
```
import urllib
import urllib2
 
values={}
values['username'] = "xxxxx"
values['password']="XXXX"
data = urllib.urlencode(values) 
url = "http://passport.csdn.net/account/login"
geturl = url + "?"+data
request = urllib2.Request(geturl)
response = urllib2.urlopen(request)
print response.read()
```

####设置Headers
有些网站不允许程序直接通过上面的方式进行访问，因此需要设置一些Header属性，达到模拟浏览器的工作。
Header中包含了许许多多的信息，有文件编码、压缩方式、请求的agent等，agent是请求的身份，如果没有设置agent，服务器就不一定会响应，因此要在Header中设置agent。
```
import urllib  
import urllib2  

url = 'http://www.server.com/login'
user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'  
values = {'username' : 'xxx',  'password' : 'XXXX' }  
headers = { 'User-Agent' : user_agent }  
data = urllib.urlencode(values)  
request = urllib2.Request(url, data, headers)  
response = urllib2.urlopen(request)  
page = response.read() 
```
另外还有应对“反盗链”的方式，对付反盗链，服务器会识别Header中的referer是不是服务器自己，如果不是，服务器就不会响应，所以在Header中加入referer。
```
headers = { 'User-Agent' : 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'  ,
                        'Referer':'http://www.zhihu.com/articles' }  
```
####设置代理Proxy
urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！

下面一段代码说明了代理的设置用法
```
import urllib2
enable_proxy = True
proxy_handler = urllib2.ProxyHandler({"http" : 'http://some-proxy.com:8080'})
null_proxy_handler = urllib2.ProxyHandler({})
if enable_proxy:
    opener = urllib2.build_opener(proxy_handler)
else:
    opener = urllib2.build_opener(null_proxy_handler)
urllib2.install_opener(opener)
```
####URLError异常处理
###URLError###
首先解释下URLError可能产生的原因：
1.网络无连接，即本机无法上网
2.连接不到特定的服务器
3.服务器不存在
在代码中，我们需要用try-except语句来包围并捕获相应的异常。
```
import urllib2
requset = urllib2.Request('http://www.xxxxx.com')
try:
    urllib2.urlopen(request)
except urllib2.URLError, e:
    print e.reason
```
运行结果如下：
```
[Errno 11004] getaddrinfo failed
```
它说明错误代码是11004，错误原因是getaddrinfo failed。

###HTTPError###
HTTPError是URLError的子类，在你利用urlopen方法发出一个请求时，服务器上都会对应一个应答对象response，其中它包含一个数字”状态码”。
HTTP状态码表示HTTP协议所返回的响应的状态。下面将状态码归结如下：
>100：继续  客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。
101： 转换协议  在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。
102：继续处理   由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
200：请求成功      处理方式：获得响应的内容，进行处理
201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到
202：请求被接受，但处理尚未完成    处理方式：阻塞等待
204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃
300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃
301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL
302：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL
304：请求的资源未更新     处理方式：丢弃
400：非法请求     处理方式：丢弃
401：未授权     处理方式：丢弃
403：禁止     处理方式：丢弃
404：没有找到     处理方式：丢弃
500：服务器内部错误  服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。
501：服务器无法识别  服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。
502：错误网关  作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
503：服务出错   由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。

urllib2可以为你处理重定向，也就是3开头的代号可以被处理，并且100-299范围的号码指示成功，所以你只能看到400-599的错误号码。
下面我们是一个例子，因为HTTPError是URLError的子类，根据编程经验，父类的异常应当写到子类异常的后面，如果子类捕获不到，那么可以捕获父类的异常。
```
import urllib2

req = urllib2.Request('http://blog.csdn.net/xxxx')
try:
    urllib2.urlopen(req)
except urllib2.HTTPError, e:
    print e.code
except urllib2.URLError, e:
    print e.reason
else:
    print "OK"
```
如果捕获到了HTTPError，则输出code，不会再处理URLError异常。如果发生的不是HTTPError，则会去捕获URLError异常，输出错误原因。
另外还可以加入 hasattr属性提前对属性进行判断，代码改写如下
```
import urllib2

req = urllib2.Request('http://blog.csdn.net/xxxx')
try:
    urllib2.urlopen(req)
except urllib2.URLError, e:
    if hasattr(e,"reason"):
        print e.reason
else:
    print "OK"
```
首先对异常的属性进行判断，以免出现属性输出报错的现象。

<meta http-equiv="refresh" content="50.0"> 